# 破坏性的服务变更
微服务作为更大的系统的一部分而存在。每个微服务要么使用其他微服务提供的功能，要么向其他微服务提供自己的功能，要么二者兼而有之。对于微服务架构而言，我们正在努力实现其独立可部署性。但是为了实现其独立部署，我们需要确保对微服务的修改不会干扰其下游消费者。

我们可以用契约的形式把服务的功能开放给其它的微服务。契约并不仅仅用来描述：“微服务将返回的数据”。契约还涉及到定义服务的预期行为。无论是否与下游服务明确的建立该契约，该契约都会存在。当修改服务时，需要确保没有违反该契约；否则，就会出现严重的线上问题。

我们迟早都要应对破坏性变化所带来的挑战——要么是因为有意做出的非向后兼容变更的决定，要么是因为无意的修改。对于无意而为之的修改，我们以为他只会影响本地服务，却发现它以难以想象的方式破坏了其他的服务。

## 该问题如何表现出来
此问题最严重的情况是，因破坏契约兼容性的、新的微服务生效而导致的系统中断。这表明，我们没有尽早捕捉意外的破坏契约的行为。如果没有快速的回滚机制，那么这些问题将是灾难性的。解决这种类型的故障的唯一的优势就是，除非修改的是很少使用的那部分服务，否则变更发布之后，很快就会表现出这类故障。

另一种迹象是，我们开始发现人们试图协调多个服务的同时部署（有时称之为同步发布（*lock-step release*））。在试图管理客户端和服务器之间的契约变化时，也可能会出现该现象。在团队中，偶尔的同步发布并不会太糟，但是如果同步发布很常见，则需要进行一些调查。

## 该问题何时会出现
我发现，破坏性修改的问题是团队很早就能遇到的发展烦恼，尤其是当开发跨越多个团队时。在一个团队中时，人们在做出破坏性修改时往往会有更清楚的认识，部分原因是开发人员很有可能会同时修改服务和该服务的消费者。当一个团队正在修改其他团队会使用的服务时，可能会更频繁的出现破坏性修改的问题。

随着时间的流逝，随着团队变得越来越成熟，团队会更加努力地做出改变来避免出现故障，并且还建立机制来尽早发现问题。

## 该问题的解决方案

