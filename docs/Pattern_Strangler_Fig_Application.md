# 绞杀者模式
绞杀者模式是一种系统重写的常见技术。[Martin Fowler](https://martinfowler.com/)从某种藤类植物汲取灵感，并首次提出了[绞杀者模式](https://martinfowler.com/bliki/StranglerFigApplication.html)。这种藤生长于树上部的树枝，然后朝着地面的方向生长并落地生根，最后逐渐包围原来的树木。这种藤所包围的树为新的藤提供最初的结构支撑，并且如果到最后阶段，我们可能会看到原来的树死了、并且腐烂了，只剩下了新的、现在自支撑的藤。

{% hint style='working' %}

**Martin Flower博客中提到的绞杀藤图片**

![](../images/fig.jpg)

{% endhint %}

与此类似，在软件开发中，我们的新系统最初应由现有系统支持和包装。这个主意就是：新、旧系统可以共存，给予新系统成长的时间，并完全替代旧系统。我们将很快看到，这种模式的主要好处是它支持我们增量迁移到新系统的目标。而且，这种模式使我们在可以利用已经发布的新系统的优势的同时，具备暂停甚至完全停止迁移的能力。

很快就会看到，当我们在软件中实现绞杀者模式时，我们不仅要努力朝着新的应用程序架构迈进，而且还要确保每一步都易于逆转，从而降低每一步的风险。

## 绞杀者模式是如何工作的
虽然绞杀藤模式通常用于从一个单体系统迁移到另一个单体系统，但我们希望利用绞杀藤模式将单体系统迁移到一系列微服务。这可能涉及从单体中复制代码（如果可能），或者重新实现所讨论的功能。另外，如果所讨论的功能需要状态的持久化，则需要考虑如何将该状态迁移到新服务，并需要考虑如何再将该状态迁移单体。我们将在第4章中探讨与数据相关的迁移模式。

如[图3-1](#f31)所示，实现绞杀者模式需要三个步骤：

1. 首先，确定现有系统中要迁移的部分。需要使用我们在[第2章](Trade_Offs.md)中讨论的那种权衡方式，来判断要首先解决系统的哪些部分。
2. 然后，需要在新的微服务中实现此功能。
3. 在准备好新的实现之后，需要能够将调用从单体重新路由到新的微服务。

![](../images/3_1.png)

<span id='f31'>图3-1</span>. 绞杀者模式概览

值得注意的是，在将调用重定向到迁移之后的服务之前，即使已将新功能部署到生产环境中，从技术而言，该新功能也还是没有启用的。这意味着我们可能会花一些时间来正确使用该功能，并在一段时间内实现该功能。我们可以将这些更改推送到生产环境中，并在了解到我们尚未使用新服务的情况下而对更改感到安全。这也让我们对新服务的部署和管理感到满意。一旦新服务实现了与单体一样的等效功能，就可以考虑使用类似并行运行（*parallel run*）的模式（稍后将探讨并行运行模式），让我们确信新功能可以按照预期运行。

{% hint style='info' %}

区分部署（*deployment*）和发布（*release*）的概念非常重要。仅仅j把软件部署到给定的环境并不意味着用户实际上正在使用它。将这两件事视为独立的概念，可以在服务使用前在最终的生产环境中验证软件的能力，从而可以降低新软件的风险。类似绞杀者的模式，并行运行（*parallel run*）和金丝雀发布（*canary release*）之类的模式就利用了部署和发布是独立活动这一事实。

{% endhint %}

这种绞杀者方法的关键点不仅在于我们可以逐步将新功能迁移到新系统，并且如果需要，我们还可以非常轻松地回滚此变更。记住，我们都会犯错，因此我们希望拥有一种技术，使我们不仅可以尽可能低成本地犯错误（因此会有很多小步骤），而且还可以快速修正错误。

如果单体内部的其他功能也会用到正在抽取的功能，则我们还需要更改这些调用的方式。 我们将在本章的后面介绍一些技术用于解决这种场景。

## 何处使用绞杀者模式
绞杀者模式可让我们在无需触碰或修改现有系统的情况下将功能迁移至新的服务架构。当现有的单体还由其他人一起开发时，绞杀者模式可以减少不同人员之间的冲突。当单体程序实际上是一个黑盒系统（例如，第三方软件或SaaS服务）时，绞杀者模式也非常有用。

有时，我们可以一次提取一个完整的、端到端的、功能切片，如[图3-2](#f32)所示。除了对数据的担忧之外，这大大简化了功能抽取的过程。我们将在本书的后面部分介绍数据相关的内容。

![](../images/3_2.png)

<span id='f32'>图3-2</span>. 库存管理功能的简单的端对端的抽象

为了执行这种整洁的（*clean*）端到端抽取，我们可能倾向于提取更大的功能组以简化该过程。这可能会导致一个比较棘手的平衡——抽取更大的功能切片，将会承担更多的工作，但会简化某些集成的挑战。

如果我们确实想“蚕食”，我们可能需要考虑更多的“浅”抽取，如[图3-3](#f33)所示。此时，我们会抽取Payroll功能，但是实际上，Payroll功能会依赖仍旧位于单体中的其他功能，例如此例中的发送用户通知的功能。

![](../images/3_3.png)

<span id='f33'>图3-3</span>. 抽取仍需要依赖单体的功能

我们没有重新实现User Notifications功能，而是通过从单体公开了该功能，从而向我们的新微服务提供了User Nofitifications功能——显然，这需要对单体本身作出更改。

我们没有重新实现User Notifications功能，而是通过从单体公开了该功能，从而向我们的新微服务提供了User Nofitifications功能——显然，这需要对单体本身作出更改。

但是，为了使绞杀者模式可以发挥作用，我们需要理清我们关注的功能到我们希望迁移的部分的[入站](Domain_Driven_Design.md#fn_译注3)调用图。例如，在[图3-4](#f34)中，我们理想的情况是迁移给用户发送User Notifications的功能到一项新服务中。但是，由于该通知由现有单体的多个入站调用而触发，因此，我们无法清晰地重定向来自系统外部的调用。取而代之的是，我们需要研究一种类似于第104页[^译注1]的“[抽象分支模式](Pattern_Branch_by_Abstraction.md)”中所述的技术。

![](../images/3_4.png)

<span id='f34'>图3-4</span>. 当要迁移的功能位于现有系统的较深的层次时，则绞杀者模式无法发挥作用

我们还需要考虑对现有系统进行请求的调用的性质。正如我们稍后将探讨的，类似HTTP之类的协议非常适合**重定向**。

HTTP本身具有内置的透明重定向的概念，代理可以使用该概念来清晰的了解入站请求的性质并做出对应的转发。其他类型的协议（例如某些RPC）则可能不太适合重定向。我们需要在代理层做的用来理解并转发入站调用的功能越多，则此协议的可行性越小。

尽管有这些限制，但绞杀者模式一次又一次地证明了自己是一种非常有用的迁移技术。作为一种轻巧易用、且易于处理增量变更的方法，在探索如何迁移系统时，绞杀者模式通常是我的首选方法。

## HTTP反向代理
HTTP具有某些很有趣的能力。HTTP可以轻而易举的以一种对调用者透明的方式对请求进行拦截并重定向。这意味着可以使用绞杀者模式迁移现有的、HTTP接口的单体系统。

在[图3-5](#f35)中，我们看到了对外公开HTTP接口的现有单体系统。该应用程序可能是**无头应用**（*headless*）[^译注2]，或者实际上可能是由上游UI调用的HTTP接口。无论哪种方式，我们的目标都是相同的：在上游调用和下游单体之间插入一个HTTP反向代理。

![](../images/3_5.png)

<span id='f35'>图3-5</span>. 应用绞杀者模式前的以HTTP驱动的单体系统 

{% hint style='working' %}

**正向代理和反向代理**

代理有正向代理和反向代理之分，因此，在继续探讨之前，需要对不同的代理有一个概念上的区分。

如果从代理的对象而言，我们可以较为容易的对二者进行区分。

如果，代理是用来代表用户访问原来用户无法直接访问到的资源，这种情况就属于正向代理。在使用正向代理时，用户一般需要手动进行配置，例如`export http_proxy=http://127.0.0.1:1087`，用户也会非常明确，此时是使用代理来访问目标资源。

如果，代理对于用户是透明的，代理是用来代理所访问的资源时，这个时候的代理就属于反向代理。例如nginx在做负载均衡时所起到的作用。

{% endhint %}

### 步骤1：插入反向代理
除非已经有了合适的、可重复使用的HTTP反向代理，否则建议首先让HTTP反向代理就位，如[图3-6](#f36)所示。在第一步中，反向代理无需对请求做任何处理，只是仅仅透传所有的调用。

![](../images/3_6.png)

<span id='f36'>图3-6</span>. 步骤1：在单体和上游系统之间插入反向代理

通过此步骤，我们可以评估在上游调用和下游单体之间增加额外的网络节点的影响。我们需要对新增加的代理组件设置任何必须的监控，并且基本上需要观察一段时间。从延迟的角度来看，我们将在所有请求的处理路径中增加一个网络节点和处理进程。我们期望使用良好的代理和网络来使得对延迟的影响最小（也许在几毫秒左右）。但是，如果事实并非如此，则我们有机会停下步伐并在继续前进之前将延迟太大的问题调查清楚。

如果单体前面的代理已经就绪，则可以跳过此步骤。但是，务必确保我们了解如何重新配置此代理以重定向请求。我建议至少要有重定向的经验，以在假定稍后代理可以工作前确保代理可以按照预期工作。如果在打算给新服务发送请求之前，就发现这是不可能的，那这真是令人讨厌的惊喜！

### 步骤2：迁移功能
如[图3-7](#f37)所示，一旦我们的HTTP 反向代理就绪，接下来，我们就要开始抽取我们的新的微服务。

![](../images/3_7.png)

<span id='f37'>图3-7</span>. 增量实现要迁移的功能

此步骤本身可以分为多个阶段。首先，在没有实现任何功能的情况下，启动并运行基本服务。服务需要能够接收对应功能的调用，但是在此阶段，可以只返回**501 Not Implemented**。即使在这一步，我们也会将此服务部署到生产环境中。这使我们可以熟悉生产部署过程，并可以测试就绪的服务。此时，我们的新服务尚未发布，因为我们尚未重定向现有的上游调用。实际上，我们将软件部署从软件发布中区分开来，这是一种常见的发布技术，稍后我们将再次介绍。

### 步骤3：调用重定向
如[图3-8](#f38)所示，一旦我们完成了需要迁移的所有功能，我们重新配置代理即可实现调用的重定向。如果由于某种原因而失败，那么我们可以将重定向切换回去——对于大多数代理来说，这是一个非常快速和容易的过程，从而可以实现快速回滚。

![](../images/3_8.png)

<span id='f38'>图3-8</span>. 将调用重定向到Payroll功能，然后完成迁移

我们可能决定使用某种类似功能切换之类的方法来实现重定向，这种方式可以使所需的配置状态更加明显。在使用金丝雀发布时，可以考虑使用代理重定向调用的方式来实现增量发布新功能。当然，也可以应用于并行运行模式，或者其他本章将会讨论的模式。

## 如何解决数据的迁移？
到目前为止，我们还没有谈论如何迁移数据。在[图3-8](#f38)中，如果我们新迁移的Payroll服务需要访问单体中的数据库时，我们该怎么办？ 关于数据的迁移，我们将在第4章中更全面地探讨。

## 代理的选择
代理的实现方式部分取决于单体使用的协议。如果现有的单体使用HTTP，那么会是一个不错的开始。对HTTP的支持如此的广泛，以至于对管理重定向而言，我们有太多的选择。我可能会选择像NGINX这样的专用于代理的软件。NGINX是在考虑了这类场景的情况下而创建的，并且可以支持多种重定向的机制。我们可以尝试并测试NGINX提供的不同的重定向机制，并且这些重定向机制看起来表现非常好。

相较于某些重定向，有的重定向更简单。考虑使用**URI path**来重定向，也许就像REST[^译注3]资源所展示的那样。在[图3-9](#f39)中，我们将整个Invoice资源迁移到了我们的新服务上，这很容易通过解析**URI path**来实现重定向。

![](../images/3_9.png)

<span id='f39'>图3-9</span>. 根据资源重定向

但是，如果当前的系统把关于被调用的功能特性的信息隐藏于请求体（*request body*）中（可能是表单参数），则我们需要利用POST参数来控制重定向规则，这种方式有时是可以的，但是会更复杂。如果我们发现我们遇到了这种情况，此时有必要检查我们可以选择的代理，以确保它们能够处理这种场景。

如果截获并重定向的特性太过复杂，或者单体所使用的协议的支持力度并不广泛，此时，我们可能会动心去自己编写一些代码。但是，对于自己编写代码的这种方法而言，我们要非常谨慎。之前，我已经手工编写了几个网络代理（一个用Java实现，另一个用Python实现），但是，这可能只能用来说明我的编码能力。并且在各种场景下，我自己编写的代理的效率都非常低，这大大增加了系统的延迟。如今，如果我需要更多的自定义功能，我可能会考虑将自定义功能添加到一个专用代理中。例如，NGINX允许我们使用Lua来为NGINX增加自定义功能。

### 增量推新
如[图3-10](#f310)所示，反向代理技术允许通过一系列小步骤改变架构，并且，每一个的小步骤都可以与系统的其他工作一起完成。

![](../images/3_10.png)

<span id='f310'>图3-10</span>. 基于HTTP的绞杀者模式的实现

我们可能会认为，完全切换到Payroll功能的新实现的工作量仍然太大。在这种情况下，可以迁移较少的功能。例如，如[图3-11](#f311)所示，可以考虑仅迁移部分Payroll功能并适当的转换调用方式——部分功能在单体中实现，部分功能在微服务中实现。如果单体和微服务中的功能都需要查看同一组数据，则可能会导致问题。此时可能需要共享数据库，并且会带来因共享数据库而导致的所有问题。

没有巨大的变更，在架构升级时，无需停止升级的进程[^译注4]。代理技术可以更容易的将迁移工作拆解为多个阶段，并且还可以与其他交付工作一起交付。与其将工作（*backlog*）拆分为“feature”story 和“technical”story，不如将所有这些工作放在一起。要擅长增量修改技术0架构，同时又能提供新功能！

![](../images/3_11.png)

<span id='f311'>图3-11</span>. 基于HTTP的绞杀者模式的实现

## 改变协议


---
[^译注1]: 此处对应的是英文原书的第104页，而不是翻译之后的页数。
[^译注2]: headless为没有UI驱动的应用程序，例如谷歌浏览器的headless模式。
[^译注3]: REST: REpresentational State Transfer，也就是“表述性状态转换”。REST来自于Roy Fielding的[博士论文](https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm)。基于这篇论文里的理论，衍生出了RESTFul API的接口设计风格。
[^译注4]: 原文为：No big bang, stop-the-line re-platforming required.
[^译注5]: smart endpoints and dumb pipes: https://martinfowler.com/articles/microservices.html#SmartEndpointsAndDumbPipes